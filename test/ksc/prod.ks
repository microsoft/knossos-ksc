; rev$prod{n} generated by LM-based reverse mode is quadratic in n.
; It calls not only rev$prod{n-1} and rev$mul but also prod{n}.  At
; the time of writing, for example
;
;     def rev$prod6 Float (_t1 : (Float, Float))
;      = (let { x : Float = get$1$2(_t1) }
;         (let { t$684 : (Float, Float)
;                  = rev$mul((x, prod5(x)), get$2$2(_t1)) }
;          get$1$2(t$684) `ts_add` rev$prod5(x, get$2$2(t$684))))
;
; Not even CSE can remove the duplication, because it occurs across
; function boundaries.
;
; On the other hand, fwds$prod{n} (be careful with terminology: this
; is the forward sweep of reverse mode AD, not forward mode AD) only
; calls fwds$prod{n-1} and fwds$mul (once each).  Similarly,
; revs$prod{n} (the reverse sweep of reverse mode) only calls
; revs$prod{n-1} and revs$mul (once each).  Therefore it is linear in
; n.
(def prod1 Float (x : Float)
     x)

(def prod2 Float (x : Float)
     (mul x (prod1 x)))

(def prod3 Float (x : Float)
     (mul x (prod2 x)))

(def prod4 Float (x : Float)
     (mul x (prod3 x)))

(def prod5 Float (x : Float)
     (mul x (prod4 x)))

(def prod6 Float (x : Float)
     (mul x (prod5 x)))
