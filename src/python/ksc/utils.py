import itertools

import importlib.util
import os
from tempfile import NamedTemporaryFile
from contextlib import contextmanager


class KRecord:
    """
    A smoother namedtuple -- like https://pythonhosted.org/pyrecord but using the existing class syntax.
    Like a 3.7 dataclass, but don't need to decorate each derived class

    Derive a class from KRecord, declare its fields, and use keyword args in __init__

    def MyClass(KRecord):
        cost: float
        names: List[String]

        def __init__(cost, names):
            super().__init__(cost=cost, names=names)

    And now you have a nice little record class.

    Construct a MyClass:
        a = MyClass(1.3, ["fred", "conor", "una"])

    Compare two MyClasses
        if a == b: ...
    
    Etc
    """

    def __init__(self, **args):
        for (nt, v) in args.items():
            # assert nt in self.__annotations__  # <- This check will fail for chains of derived classes -- only the deepest has __annotations__ ready yet.
            setattr(self, nt, v)

    def __eq__(self, that):
        if type(self) != type(that):
            return False

        for nt in self.__annotations__:
            if getattr(self, nt) != getattr(that, nt):
                return False
        return True


def ensure_list_of_lists(l):
    """return input, wrapped in a singleton list if its first element is not a list

       ensure_list_of_lists([])    = []
       ensure_list_of_lists([1])   = [[1]]
       ensure_list_of_lists([[1]]) = [[1]]
       ensure_list_of_lists([[1,2]])        = [[1, 2]]
       ensure_list_of_lists([[1,2], [3,4]]) = [[1, 2], [3, 4]]
    """

    if not isinstance(l, list):
        raise ValueError("Expect a list")
    if len(l) < 1:  # Empty list is empty list
        return l
    if not isinstance(l[0], list):
        return [l]
    else:
        return l


def single_elem(l):
    assert len(l) == 1
    return l[0]


def paren(s):
    return "(" + s + ")"


PYTHON_MODULE_NAME = "ks_mod"


def import_module_from_path(module_name, path):
    # These three lines are for loading a module from a file in Python 3.5+
    # https://bugs.python.org/issue21436
    spec = importlib.util.spec_from_file_location(module_name, path)
    py_out = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(py_out)
    return py_out


def translate_and_import(source_file_name, *args):
    from ksc.translate import translate

    py_out = translate(*args, source_file_name, with_main=False)
    with NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
        f.write(f"# AUTOGEN from {source_file_name} via ksc.utils.translate_and_import")
        f.write(py_out)

    print(f.name)
    return import_module_from_path(PYTHON_MODULE_NAME, f.name)


def get_ksc_dir():
    if "KSC_RUNTIME_DIR" in os.environ:
        ksc_runtime_dir = os.environ["KSC_RUNTIME_DIR"]
        ksc_src = os.path.dirname(ksc_runtime_dir)
        return os.path.dirname(ksc_src)

    d = os.path.dirname(__file__)  # src/python/ksc
    d = os.path.dirname(d)  # src/python
    d = os.path.dirname(d)  # src
    return os.path.dirname(d)


def get_ksc_build_dir():
    return get_ksc_dir() + "/build"


def get_ksc_paths():
    if "KSC_RUNTIME_DIR" in os.environ:
        ksc_runtime_dir = os.environ["KSC_RUNTIME_DIR"]
    else:
        ksc_runtime_dir = get_ksc_dir() + "/src/runtime"

    if "KSC_PATH" in os.environ:  # TODO: We should deprecate this
        ksc_path = os.environ["KSC_PATH"]
    else:
        ksc_path = get_ksc_build_dir() + "/bin/ksc"

    return ksc_path, ksc_runtime_dir


def encode_name(s: str) -> str:
    # TODO: this could be faster
    return (
        s.replace("@", "$a")
        .replace(",", "$_")
        .replace(".", "$o")
        .replace("[", "$6")
        .replace("]", "$9")
        .replace("<", "$d")
        .replace(">", "$b")
        .replace("*", "$x")
        .replace(":", "$8")
    )


def ndgrid_inds(sz):
    """
    Return a sequnce of tuples of indices as if generated by nested comprehensions.
    Example:
        ndgrid_inds((ni,nj))
    Returns the same sequence as
        [(i,j) for i in range(ni) for j in range(nj)]

    The iterates are always tuples so
        ndgrid_inds(4)
    returns
        [(0,), (1,), (2,), (3,)] 

    """

    return itertools.product(*map(range, sz))


def singleton(cls):
    """ Simple decorator that makes a single instance of a class.
        @singleton
        class Foo:
            def do_foo(self):
                .....
        Foo.do_foo()
    """
    return cls()


# https://stackoverflow.com/a/41904558/35544
# submodule_search_locations doesn't work for this
@contextmanager
def add_to_path(p):
    import sys

    old_path = sys.path
    old_modules = sys.modules
    sys.modules = old_modules.copy()
    sys.path = sys.path[:]
    sys.path.insert(0, p)
    try:
        yield
    finally:
        sys.path = old_path
        sys.modules = old_modules


import os.path


def write_file_if_different(lines, filename, verbose):
    """
    Write LINES to FILENAME unless they are identical to the current contents
    If VERBOSE, print info to stdout.
    """
    to_write = "\n".join(lines)
    if os.path.isfile(filename):
        # Read from file
        with open(filename, "r") as f:
            existing_contents = f.read()

        # Compare to new
        if existing_contents == to_write:
            if verbose:
                print(f"ksc.utils: File not changed: {filename}")
            return

    # And overwrite if different
    if verbose:
        print(f"ksc.utils: File changed, overwriting {filename}")

    with open(filename, "w") as f:
        f.write(to_write)
