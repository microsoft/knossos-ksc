# Introduction

#953 introduces lifting rules, for example "add-of-if" to "if-of-add", 
```clojure
(add (if p 5 3) 2)   ==lift-if==>   (if p (add 5 2) (add 3 2))
```
or more generally "call-of-if to if-of-call".

And "if-of-let to let-of-if":
```clojure
(if p (let (x a) expr1) expr2)  
;==lift-if==>  
(let (x a)  (if p expr1 expr2))  ; checking x not in freeVars of expr2 or p
```

These rules are crucial to enable CSE, or to move `if`s around in order to eliminate redundant comparisons such as `(if p (if p t1 f1) f2) ==> (if p t1 f2)`.

# Problem

However these rules can result in executing code earlier than they would have otherwise, with disastrous results -- a program which never crashed can be rewritten into one that does:
```clojure
(if (inRange i arr)
    (let (x (index i arr)) ; index is protected by "if inRange"
        expr1) 
    expr2)
;==lift-let==>
(let (x (index i arr)) ; index no longer protected, may well crash
    (if (inRange i arr) 
        expr1
        expr2))
```
Indeed, it's *likely* that it will crash, because the programmer was protecting the call in the first place.  (Ignore theorem-proving our way out of this, that's a hope, not a guarantee.)

We can't just disable lifting of any expression which might throw -- almost all of our code uses "index", and proving nothrow is hard.  So how do we disallow lifting the "if"s above, and yet allow it for almost identical code like this:
```clojure
(if (inRange j arr)
    (let (x (index i arr)) ; index is _not_ protected by "if inRange" because it checks j, not i, so we're free to lift
        expr1) 
    expr2)
```

## Solution: ifs with proofs

Putting aside theorem proving, we would like a way for the programmer to tell us which functions depend on which conditions.   This is done using "proofs" as outlined in #953.  First, we provide a new function ``index-with-proof``, defined like ``index``, but with a new argument of type `Proof`.  
```clojure
(edef index T ((i : Integer) (x : Tensor T))
(edef index-with-proof T ((p : Proof) (i : Integer) (x : Tensor T)))
```
We won't define `Proof` yet, but it will turn out to be always erased at runtime, so it might as well be the empty tuple.
It's also going to turn out that `index-with-proof` is exactly a call to `index`, with exactly the same behaviour.  The only function of the `edef` is to ensure we can't inline it away.

So why pass the Proof at all?  Well, let's see where we get `Proof`s from.   A "Proof" is a variable that exists in only one branch of an `if`.  The programmer uses it to indicate computations that depend for their correctness on being on a certain branch.  

Repeating the example above, we used a *comment* to show which check was protecting the call to index:
```clojure
(if (inRange i arr)
    (let (x (index i arr)) ; index is protected by "if inRange"
        expr1) 
    expr2)
```
The comment is helpful for the reader of the code, but not for the compiler.  To tell the compiler, we use a "proof", generated by the construct `if-with-proof`.
What does that look like?
```clojure
(if-with-proof i_ok (inRange i arr) ; 'i_ok' is just a variable name, chosen by the user
    (let (x (index-with-proof i_ok#t i arr)) ; index is protected by "i_ok on its true branch", or "i_ok#t"
        expr1) 
    expr2)
```
Let's break that down.  The new construct is `(if-with-proof IDENT EXPR EXPR EXPR)`, which can be considered to rewrite to the following, where `let!` is an "immovable" synonym for `let`, which can never be lifted over an `if`.
```clojure
(if-with-proof var cond t_body f_body)
; ==> 
(if cond
   (let! (var#t (dummy Proof))
       t_body)
   (let! (var#f (dummy Proof))
       f_body)
```
Now, expressions in `t_body` that don't refer to `var#t` can happily be lifted.  But any use of `var#t` cannot.

So let's see it in action.  Our "inRange j" variant above will be written as follows.  (We're assuming the `inRange j` was not a typo, so the programmer was using it in a way that uses its own proof `jay_ok`)
```clojure
(if-with-proof jay_ok (inRange j arr)
    (let (x (index-with-proof eye_ok#t i arr)) ; eye_ok#t must be coming from some proof above.
        expr1) 
    expr2)
```
and will rewrite happily to 
```clojure
(let (x (index-with-proof eye_ok#t i arr)) ; eye_ok#t not in freeVars of (inRange j arr).
    (if-with-proof jay_ok (inRange j arr)
        expr1) 
    expr2)
```

## Always evaluated
While in some cases `p` may determine whether `index` throws an exception, there are also interesting cases when `p` bears no relation, for example, we *would* like to permit lifting the "let" to outside the "if" in the following:
```clojure
(if fred (let (x (index i arr)) e[x]) (let (y (index i arr)) e2[y]))
;==lift-let==>
(let (x (index i arr)) (if fred e[x] (let (y (index i arr)) e2[y])))
;==lift-let==cse-bind==>
(let (x (index i arr)) (if fred e[x] e2[x]))
```
The first step cannot cause the program to throw new exceptions, because `index i arr` was *always going to be* evaluated.  This is trivially handled as above - the calls to `index` are replaced by `index-with-proof`, and the referenced proof variables are not declared by  `if fred`.

Another case trivially handled:
```clojure
(let (x (index i arr))
    (add x
        (if fred 
            (let (y (index i arr))
                e[y])
            e2)))
```
here it is safe to lift `let y` outside the inner `if` to:
```
(let (x (index i arr))
    (add x
        (let (y (index i arr))
            (if fred 
                e[y]
                e2)))
```
allowing another lifting step and cse step to produce `(let (x (index i arr)) (add x (if fred e[x] e2)))`.


## Rewrites specifying proofs
We should be able to get the rewriter to introduce the data dependencies automatically:
```clojure
(index i arr)
; ==>
(if-with-proof proof1 (inRange i arr)
  (index-with-proof proof1#t i arr)
  (throw-with-proof proof1#f OutOfBounds))
```
and then it should be possible to push (sink) the proofs *downwards* (rather than lifting upwards) and CSE identical proofs. One can also imagine a language construct `let-with-proof ((x proof) e) body` which binds both x and proof within body, where the "proof" guarantees that "e" did not throw an exception; again it should be possible to sink `proof` down and CSE with other identical proofs.


# Alternative
(An alternative formulation is via a function, parametric in Result type: `edef evalOneWithProof Result ((cond : bool) (t_body: Lam Proof Result) (f_body: Lam Proof Result))` - this does not even need new node types).

----
# Sinking
For this case where we would like to CSE the two `index`s:
```
(let (x (index i arr))
 (add x
      (if fred (let (y (index i arr)) e[y])
               e2)))
```
Maybe all we need, rather than lifting `y` up, is to allow `x` to be sunk/pushed-down:
```
(let (x (index i arr))
 (add x
     (if fred (known-binding (x (index i arr)) (let (y (index i arr)) e[y]))
            e2)))
```
with a rewrite:
```(known-binding (x e) (let (y e) body)) ==> (known-binding (x e) (let (y x) body))```
which is much like the cse-bind rule (or one variant thereof):
```(let (x e) (let (y e) body)) ==> (let (x e) (let (y x) body))```
However `known-binding` differs from `let` in that known-binding can *always* be deleted, whereas `let` can only be deleted when the bound variable is unused in the body.
(`known-binding (x e) body` is also a bit like `assert (eq x e) body` but again known-binding can just be deleted, whereas arbitrarily deleting asserts could change an exception-throwing program into one that displays a wrong answer.)